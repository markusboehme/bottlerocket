#!/usr/bin/env bash

# Helper script for running commands to generate Secure Boot files.

set -euo pipefail

usage() {
   cat >&2 <<EOF
usage: ${0##*/} FIXME

Generate Secure Boot related files. AWS-aware edition.

Options:

    --sdk-image           Name of the (optional) SDK image to use.
    --aws-region          AWS region where the resources live.
    --private-ca          ID for the Private Certificate Authority.
    --platform-key        KMS key ID for the platform key (PK).
    --key-exchange-key    KMS key ID for the key exchange key (KEK).
    --code-sign-key       KMS key ID for the code signing key (shim, grub, vmlinuz).
    --config-sign-key     KMS key ID for the config signing key (grub.cfg).
    --output-dir          Path where the keys will be written.
    --help                shows this usage text
EOF
}

required_arg() {
   local arg="${1:?}"
   local value="${2}"
   if [ -z "${value}" ]; then
      echo "ERROR: ${arg} is required" >&2
      exit 2
   fi
}

parse_args() {
  while [ ${#} -gt 0 ] ; do
    case "${1}" in
        --help ) usage; exit 0 ;;
        --sdk-image ) shift; SDK_IMAGE="${1}" ;;
        --aws-region ) shift; AWS_REGION="${1}" ;;
        --private-ca ) shift; PRIVATE_CA="${1}" ;;
        --platform-key ) shift; PLATFORM_KEY="${1}" ;;
        --key-exchange-key ) shift; KEY_EXCHANGE_KEY="${1}" ;;
        --code-sign-key ) shift; CODE_SIGN_KEY="${1}" ;;
        --config-sign-key ) shift; CONFIG_SIGN_KEY="${1}" ;;
        --output-dir ) shift; OUTPUT_DIR="${1}" ;;
        *) ;;
    esac
    shift
  done

  # Required arguments
  required_arg "--aws-region" "${AWS_REGION:-}"
  required_arg "--private-ca" "${PRIVATE_CA:-}"
  required_arg "--platform-key" "${PLATFORM_KEY:-}"
  required_arg "--key-exchange-key" "${KEY_EXCHANGE_KEY:-}"
  required_arg "--code-sign-key" "${CODE_SIGN_KEY:-}"
  required_arg "--config-sign-key" "${CONFIG_SIGN_KEY:-}"
  required_arg "--output-dir" "${OUTPUT_DIR:-}"
}

parse_args "${@}"

PRELUDE_END=$(awk '/=\^\.\.\^=/ { print NR+1; exit 0; }' "${0}")
SBKEYS_SCRIPT="$(mktemp)"
AWS_KMS_PKCS11_CONF="$(mktemp)"
cleanup() {
  rm -f "${SBKEYS_SCRIPT}" "${AWS_KMS_PKCS11_CONF}"
}
trap 'cleanup' EXIT
tail -n +"${PRELUDE_END}" "${0}" >"${SBKEYS_SCRIPT}"
chmod +x "${SBKEYS_SCRIPT}"

cat <<EOF > "${AWS_KMS_PKCS11_CONF}"
{
  "slots": [
    {
      "label": "platform-key",
      "kms_key_id": "${PLATFORM_KEY}",
      "aws_region": "${AWS_REGION}"
    },
    {
      "label": "key-exchange-key",
      "kms_key_id": "${KEY_EXCHANGE_KEY}",
      "aws_region": "${AWS_REGION}"
    },
    {
      "label": "code-sign-key",
      "kms_key_id": "${CODE_SIGN_KEY}",
      "aws_region": "${AWS_REGION}"
    },
    {
      "label": "config-sign-key",
      "kms_key_id": "${CONFIG_SIGN_KEY}",
      "aws_region": "${AWS_REGION}"
    }
  ]
}
EOF

if [ -n "${SDK_IMAGE:-}" ] ; then
  docker run -a stdin -a stdout -a stderr --rm \
    --user "$(id -u):$(id -g)" \
    --security-opt label:disable \
    -v "${OUTPUT_DIR}":/tmp/output \
    -v "${SBKEYS_SCRIPT}":/tmp/sbkeys \
    -v "${AWS_KMS_PKCS11_CONF}":/tmp/aws-kms-pkcs11-conf \
    -v "${AWS_CONFIG_FILE:-$HOME/.aws/config}":/tmp/.aws/config \
    -v "${AWS_SHARED_CREDENTIALS_FILE:-$HOME/.aws/credentials}":/tmp/.aws/credentials \
    ${AWS_PROFILE:+-e AWS_PROFILE=$AWS_PROFILE} \
    ${AWS_DEFAULT_PROFILE:+-e AWS_DEFAULT_PROFILE=$AWS_DEFAULT_PROFILE} \
    ${AWS_ACCESS_KEY_ID:+-e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID} \
    ${AWS_SECRET_ACCESS_KEY:+-e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY} \
    ${AWS_SESSION_TOKEN:+-e AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN} \
    ${AWS_ROLE_ARN:+-e AWS_ROLE_ARN=$AWS_ROLE_ARN} \
    ${AWS_ROLE_SESSION_NAME:+-e AWS_ROLE_SESSION_NAME=$AWS_ROLE_SESSION_NAME} \
    -e AWS_REGION="${AWS_REGION}" \
    -e PRIVATE_CA="${PRIVATE_CA}" \
    -e CODE_SIGN_KEY="${CODE_SIGN_KEY}" \
    -e CONFIG_SIGN_KEY="${CONFIG_SIGN_KEY}" \
    -e AWS_CONFIG_FILE="/tmp/.aws/config" \
    -e AWS_SHARED_CREDENTIALS_FILE="/tmp/.aws/credentials" \
    -e AWS_KMS_PKCS11_CONF="/tmp/aws-kms-pkcs11-conf" \
    -e OUTPUT_DIR="/tmp/output" \
    -w /tmp \
    "${SDK_IMAGE}" bash /tmp/sbkeys
else
  export PRIVATE_CA CODE_SIGN_KEY CONFIG_SIGN_KEY
  export AWS_REGION AWS_KMS_PKCS11_CONF OUTPUT_DIR
  bash "${SBKEYS_SCRIPT}"
fi

exit

# =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=
set -euo pipefail

WORKDIR="$(mktemp -d)"
cd "${WORKDIR}"
cleanup() {
  rm -rf "${WORKDIR}"
}
trap 'cleanup' EXIT

export XDG_CONFIG_HOME="${WORKDIR}/.config"
mkdir -p "${XDG_CONFIG_HOME}/aws-kms-pkcs11"
cp "${AWS_KMS_PKCS11_CONF}" "${XDG_CONFIG_HOME}/aws-kms-pkcs11/config.json"

export AWS_DEFAULT_OUTPUT="text"
export AWS_KMS_PKCS11_DEBUG=1
export PKCS11_MODULE_PATH="/usr/lib64/pkcs11/aws_kms_pkcs11.so"

AWS_ACCOUNT_ID="$(aws sts get-caller-identity --query 'Account')"
PRIVATE_CA_ARN="arn:aws:acm-pca:${AWS_REGION}:${AWS_ACCOUNT_ID}:certificate-authority/${PRIVATE_CA}"

# Fetch CA certificate.
aws acm-pca get-certificate-authority-certificate \
  --certificate-authority-arn "${PRIVATE_CA_ARN}" \
  --query 'Certificate' > CA.crt

# Add X.509 extension for code signing.
cat <<'EOF' > codesign.json
{
  "Extensions": {
    "ExtendedKeyUsage": [
      {
        "ExtendedKeyUsageType": "CODE_SIGNING"
      },
      {
        "ExtendedKeyUsageObjectIdentifier": "1.3.6.1.4.1.311.10.3.6"
      }
    ]
  }
}
EOF

gencert() {
  local key token cn cert_arn
  key="${1:?}"
  token="${2:?}"
  cn="${3:?}"

  openssl req -new \
    -key "pkcs11:token=${token}" -keyform engine -engine pkcs11 \
    -subj "/CN=${cn}/" \
    -out "${key}.csr"
    cert_arn="$(\
    aws acm-pca issue-certificate \
      --certificate-authority-arn "${PRIVATE_CA_ARN}" \
      --template-arn arn:aws:acm-pca:::template/BlankEndEntityCertificate_APIPassthrough/V1 \
      --csr "fileb://${key}.csr" \
      --api-passthrough "file://codesign.json" \
      --signing-algorithm "SHA256WITHRSA" \
      --validity Value=365,Type="DAYS" \
      --idempotency-token "${key}" \
      --query 'CertificateArn')"

    aws acm-pca wait certificate-issued \
       --certificate-authority-arn "${PRIVATE_CA_ARN}" \
       --certificate-arn "${cert_arn}"

    aws acm-pca get-certificate \
       --certificate-authority-arn "${PRIVATE_CA_ARN}" \
       --certificate-arn "${cert_arn}" \
       --query 'Certificate' \
       > "${key}.crt"
}

# Sign EFI and GRUB signing keys.
gencert PK "platform-key" "Bottlerocket Platform Key"
gencert KEK "key-exchange-key" "Bottlerocket Key Exchange Key"
gencert code-sign "code-sign-key" "Bottlerocket Code Signing Key"
gencert config-sign "config-sign-key" "Bottlerocket Config Signing Key"

# Encode the certs for the PKCS11 helper.
CODE_SIGN_CERT="$(openssl x509 -in code-sign.crt -outform der | openssl base64 -A)"
CONFIG_SIGN_CERT="$(openssl x509 -in config-sign.crt -outform der | openssl base64 -A)"

# Reconfigure the PKCS11 helper for GPG.
cat <<EOF > "${XDG_CONFIG_HOME}/aws-kms-pkcs11/config.json"
{
  "slots": [
    {
      "label": "config-sign-key",
      "kms_key_id": "${CONFIG_SIGN_KEY}",
      "aws_region": "${AWS_REGION}",
      "certificate": "${CONFIG_SIGN_CERT}"
    }
  ]
}
EOF

# Ensure a clean GPG state.
export GNUPGHOME="${WORKDIR}"

# Configure the GPG agent and smartcard daemon.
cat <<EOF >> "${GNUPGHOME}/gpg-agent.conf"
scdaemon-program /usr/bin/gnupg-pkcs11-scd
EOF

cat <<EOF >> "${GNUPGHOME}/gnupg-pkcs11-scd.conf"
providers kms
provider-kms-library /usr/lib64/pkcs11/aws_kms_pkcs11.so
log-file /dev/null
EOF

# Have GPG agent discover the key.
gpg --card-status
KEYGRIP=$(\
  find ${GNUPGHOME}/private-keys-*.d -type f -name '*.key' -printf '%P' \
  | cut -d '.' -f1 | head -n1)

# Import the config signing key into GPG.
gpg --no-tty --expert --full-generate-key --command-fd 0 <<EOF
13
${KEYGRIP}
e
q
0
Bottlerocket Config Signing Key


EOF

# Export the GPG key.
gpg --armor --export-secret-keys > config-sign.key

# Generate EFI vars for use with EC2 or others.
GUID="$(uuidgen --random)"
virt-fw-vars \
  --set-pk "${GUID}" PK.crt \
  --add-kek "${GUID}" KEK.crt \
  --add-db "${GUID}" CA.crt \
  --secure-boot \
  --output-json "efi-vars.json"

virt-fw-vars \
  --set-json "efi-vars.json" \
  --output-aws "efi-vars.aws"

# Create the final PKCS11 helper config.
cat <<EOF > "code-sign.json"
{
  "slots": [
    {
      "label": "code-sign-key",
      "kms_key_id": "${CODE_SIGN_KEY}",
      "aws_region": "${AWS_REGION}",
      "certificate": "${CODE_SIGN_CERT}"
    },
    {
      "label": "config-sign-key",
      "kms_key_id": "${CONFIG_SIGN_KEY}",
      "aws_region": "${AWS_REGION}",
      "certificate": "${CONFIG_SIGN_CERT}"
    }
  ]
}
EOF

# Copy all expected files out.
cp -t "${OUTPUT_DIR}" \
  CA.crt \
  code-sign.json \
  config-sign.key \
  efi-vars.{aws,json}
